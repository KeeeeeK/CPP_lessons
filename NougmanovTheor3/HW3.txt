0. Что такое lvalue и rvalue ссылки, чем они отличаются друг от друга?
Условно говоря (хотя и совсем не точно): lvalue - всё что изменяемо, rvalue - всё что неизменяемо.
Определение с точки зрения организации памяти: 
"
lvalue, тип которого не является массивом, не является неполным, не имеет спецификатор const, не является структурой или объединением, содержащими поля (также включая поля, рекурсивно вложенные в содержащиеся агрегаты и объединения) со спецификатором const.
" - C99
Как следует из определения (отрицание в кванторах)) - то, что обладает хотя бы одним из перечисленных свойств. 
На lvalue можно сослаться и таким образом передать область видимости над данным объектом. Где-то "там" оно может быть изменено.
На rvalue можно сослаться, но оно также останется неизменно. То есть оно неизменно и может лишь использоваться как константа для других вычислений.
Возможно приведение lvalue к rvalue. Обратное невозможно. 
rvalue может уничтожаться, например когда мы реализуем конструктор перемещения.

1. Что такое списки инициализации конструктора? Зачем они нужны?
Когда запускается конструктор, он сначала выделяет память под класс, потом обычно мы заполняли выделенную память операциями присваивания. Поскольку константные поля класса (например, размерность объекта) неизменны - им нельзя что-то присвоить даже в конструкторе, но можно инициализировать. В этом суть - перед запуском основного кода функции можно явно проинициализировать поля.

2. Какие типы конструкторов вы знаете? В чём особенность каждого из них, зачем он нужен?
0) К каждому из следующих конструкторов есть дефолтный аналог, если не указана явная реализация.
1) Конструктор копирования - очевидно, копирует класс. Вызывается всякий раз, когда мы явным образом передаём класс, а не ссылку на него, когда мы инициализируем другой класс, как lvalue. А чтобы он не вызывался миллион раз при каждом присваивании нам нужен... встречайте следующего гостя нашей программы...
2) Конструктор перемещения - &&. Применяется, когда мы инициализуруем при помощи rvalue или direct initialization.
3) Обычный конструктор... Это просто функция с таким же названием, как и класс, которая желательно должна до своего окончания проинициализировать поля класса. Они могут быть заполнены по умолчанию в строке объявления функции, могут быть присвоены внутри или заполнены через списки инициализации.

3. Как и для чего нужно использовать const в методах класса?
Если метод не должен менять значения переменных - лучше сделать его константным. Константные методы соответственно могут вызывать только константные методы. Как и многие другие вещи в срр - это способ предохраняться от различных нежелательных действий других программистов в вашем большом проекте.

	Как можно переопределять операторы в с++? Какие есть ограничения?
К своим классам можно добавлять привычные взгляду операторы вместо функций от одной или двух переменных. Исключениеми являются "?_:_" , "sizeof" , "::" , "." , ".*". Разрешено переопределение только существующих операторов. Понятие "к своим классам" для дуальных операторов значит, что хотя бы один из них должен быть вашего класса. По факту автоматическое приведение к даблу инта можно тоже рассматривать как перегрузку для оператора +, например. Но самому это делать запрещается, так как это не классы и перегружать можно только невстроенные классы. Как это делается? Писать operator@, где @ - вид оператора.

	Для чего нужно ключевое слово friend?
Можно сделать дружественные классы, функции (указываются внутри внутри класса, но не являются его методами). "Друзья" имеют доступ к private разделу, в то время как если бы мы передали просто область видимости - это позволило бы заглядывать только в public.
Функция будет доступна вне класса, даже если объявлена в поле private или pritected.
Но стоит понимать, что хоть она и "друг", она не имеет указатель this.

	В чём особенность new и delete по сравнению с malloc() и free()
Во-первых в более человечном синтаксисе. Во-вторых в обработке ошибок (для new) и умном поведении (для delete). 
Синтаксис стал больше ориентирован под то, с чем мы будем работать, в то время как (T*)malloc(sizeof(T)) - частая конструкция которая к тому же не инициализирует выделенную память. new - по сути упрощает жизнь.
std::bad_alloc - исключение, генерируемое при нехватке памяти (new).
delete при удалении классов или массивов вызывает соответсвующие деструкторы. Для массива он пробегается поэлементно и вызывает деструкторы каждого из элементов. Это очень удобно.
