	Что такое lvalue и rvalue ссылки, чем они отличаются друг от друга?
Условно говоря (хотя и не очень точно): lvalue - всё что изменяемо, rvalue - всё что неизменяемо. 
Определение с точки зрения организации памяти: 
"
lvalue, тип которого не является массивом, не является неполным, не имеет спецификатор const, не является структурой или объединением, содержащими поля (также включая поля, рекурсивно вложенные в содержащиеся агрегаты и объединения) со спецификатором const.
" - C99
Как следует из определения (отрицание в кванторах)) - то, что обладает хотя бы одним из перечисленных свойств. 
Возможно неявное приведение lvalue к rvalue.
rvalue может уничтожаться, например когда мы реализуем конструктор перемещения.

	Что такое списки инициализации конструктора? Зачем они нужны?
Когда запускается конструктор, он сначала выделяет память под класс, потом обычно мы заполняли выделенную память операциями присваивания. Но можно это делать напрямую, то есть сразу заполнять выделенную память. Экономия действий компьютера, другой понятный синтаксис, позволяющий не искать в какой момент программист решил инициализировать переменные.

	Какие типы конструкторов вы знаете? В чём особенность каждого из них, зачем он нужен?
0. К каждому из следующих конструкторов есть дефолтный аналог, если не указана явная реализация.
1. Конструктор копирования - очевидно, копирует класс. Вызывается всякий раз, когда мы явным образом передаём класс, а не ссылку на него, когда мы инициализируем другой класс, как lvalue. А чтобы он не вызывался миллион раз при каждом присваивании нам нужен... встречайте следующего гостя нашей программы...
2. Конструктор перемещения - &&. Применяется, когда мы инициализуруем при помощи rvalue или direct initialization.
3. Обычный конструктор... Это просто функция с таким же названием, как и класс, которая желательно должна до своего окончания проинициализировать поля класса. Они могут быть заполнены по умолчанию в строке объявления функции, могут быть присвоены внутри или заполнены через списки инициализации.

	Как и для чего нужно использовать const в методах класса?
Если метод не должен менять значения переменных - лучше сделать его константным. Константные методы соответственно могут вызывать только константные методы. Как и многие другие вещи в срр - это способ предохраняться от различных нежелательных действий других программистов в вашем большом проекте.

	Как можно переопределять операторы в с++? Какие есть ограничение?
К своим классам можно добавлять привычные взгляду операторы вместо функций от одной или двух переменных. Исключениеми являются "?_:_" , "sizeof" , "::" , "." , ".*". Понятие "к своим классам" для дуальных операторов значит, что хотя бы один из них должен быть вашего класса. По факту автоматическое приведение к даблу инта можно тоже рассматривать как перегрузку для оператора +, например. Как это делается? Писать operator@, где @ - вид оператора.

	Для чего нужно ключевое слово friend?
Можно сделать дружественные классы, функции (указываются внутри внутри класса, но не являются его методами). "Друзья" имеют доступ к private разделу, в то время как если бы мы передали просто область видимости - это позволило бы заглядывать только в public.

	В чём особенность new и delete по сравнению с malloc() и free()
Во-первых в более человечном синтаксисе. Во-вторых в обработке ошибок (для new) и умном поведении (для delete). 
Синтаксис стал больше ориентирован под то, с чем мы будем работать, в то время как (T*)malloc(sizeof(T)) - частая конструкция которая к тому же не инициализирует выделенную память. new - по сути упрощает жизнь.
std::bad_alloc - исключение, генерируемое при нехватке памяти (new).
delete при удалении классов или массивов вызывает соответсвующие деструкторы. Для массива он пробегается поэлементно и вызывает деструкторы каждого из элементов. Это очень удобно.